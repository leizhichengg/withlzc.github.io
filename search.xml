<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>直播协议与直播流分发服务</title>
    <url>/2019/12/07/live-protocol-and-server/</url>
    <content><![CDATA[<p>常见的直播协议主要有：RTMP，HTTP-FLV，HLS等，推流一般都采用RTMP，拉流使用RTMP、HTTP-FLV或HLS协议。</p>
<a id="more"></a>

<h2 id="RTMP、HTTP-FLV、HLS"><a href="#RTMP、HTTP-FLV、HLS" class="headerlink" title="RTMP、HTTP-FLV、HLS"></a>RTMP、HTTP-FLV、HLS</h2><h3 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h3><p>RTMP（Real Time Messaging Protocol，实时消息协议），是Adobe为Flash播放器和服务器之间传输流媒体音频、视频和数据开发的一个专有协议。RTMP是基于TCP的应用层协议，默认使用端口1935。</p>
<h3 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a>HTTP-FLV</h3><p>HTTP-FLV，将音视频数据封装为FLV格式，然后通过HTTP协议传输给客户端。HTTP-FLV依靠MIME的特性，根据协议中的Content-Type来选择相应的程序去处理相应的内容，使得流媒体可以通过HTTP传输。</p>
<h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p>HLS（HTTP Live Streaming）是Apple提出的基于HTTP的流媒体网络传输协议。HLS的工作原理是将整个流分成一个个小的基于HTTP的ts文件来下载，并通过m3u8索引文件按序访问ts文件。客户端通过不停地按序播放从服务器获取到的文件实现播放音视频数据。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th align="center">传输协议</th>
<th align="center">RTMP</th>
<th align="center">RTMP</th>
<th align="center">HLS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">视频格式</td>
<td align="center">flv</td>
<td align="center">flv</td>
<td align="center">ts</td>
</tr>
<tr>
<td align="center">延迟</td>
<td align="center">1~3 s</td>
<td align="center">1~3 s</td>
<td align="center">&gt; 10 s</td>
</tr>
<tr>
<td align="center">HTML5播放</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<p>由于Chrome在2020年会停止支持flash player，对Web客户端来说RTMP协议将无法适用，而HLS协议的延迟较高，因此HTTP-FLV协议成为更合适的选择。HTTP-FLV可以配合flv.js实现基于HTML5播放。</p>
<p><a href="https://github.com/bilibili/flv.js" target="_blank" rel="noopener">flv.js</a>是来自于Bilibili的开源项目，它通过解析FLV文件喂给原生HTML5 Video标签播放音视频数据，使浏览器在不借助Flash的情况下播放FLV成为可能。</p>
<hr>
<h2 id="直播流分发服务"><a href="#直播流分发服务" class="headerlink" title="直播流分发服务"></a>直播流分发服务</h2><p>直播流分发一般是将本地视频文件或者其他视频源通过编码、转换等手段推送到特定协议的播放地址，直播分发服务监听RTMP端口（默认1935），获取到音视频数据后将起编码为特定的协议格式分发出去。目前接触到两个GitHub上较为常用的直播分发服务：<a href="https://github.com/gwuhaolin/livego" target="_blank" rel="noopener">livego</a>和<a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">SRS</a>。</p>
<p>livego是纯go编写的直播服务器，性能高、跨平台，支持常见的传输协议、文件格式、编码格式等。</p>
<p>SRS是一个简单的流媒体直播集群，提供丰富的接入方案将RTMP流接入SRS（包含推送RTMP流到SRS、推送RTSP、FLV到SRS等），支持将接入的RTMP流进行各种转换（例如封装为HTTP-FLV流、HLS流等）。</p>
<p>livego和SRS服务都可以直接通过docker启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">livego:</span><br><span class="line">docker run -p 1935:1935 -p 7001:7001 -p 7002:7002 -d --name livego gwuhaolin/livego</span><br><span class="line"></span><br><span class="line">SRS:</span><br><span class="line">docker run -p 1935:1935 -p 1985:1985 -p 8080:8080 ossrs/srs:3</span><br></pre></td></tr></table></figure>

<p>服务启动后使用<code>ffmpeg</code>命令进行推流：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -I demo.mp4 -c copy -f flv rtmp://localhost:1935/live/demo</span><br></pre></td></tr></table></figure>

<p>下行播放地址：</p>
<ul>
<li>RTMP: <code>rtmp:localhost:&quot;rtmp port&quot;/live/demo</code></li>
<li>HTTP-FLV: <code>http://localhost:&quot;http-flv port&quot;/live/demo.flv</code></li>
<li>HLS: <code>http://localhost:&quot;hls port&quot;/live/demo.m3u8</code></li>
</ul>
<p>在使用livego的过程中，ffmpeg推流经过一段时间后，livego服务偶尔会中断，该服务GitHub仓库issues中也多次提到该<a href="https://github.com/gwuhaolin/livego/issues/4" target="_blank" rel="noopener">问题</a>，但仍未彻底解决。SRS相较于livego更稳定，很少会出现服务中断的问题，因此最终还是选择了SRS作为推流的服务。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>rtmp</tag>
        <tag>http-flv</tag>
        <tag>hls</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang基于swagger处理业务日志</title>
    <url>/2019/11/06/go-swagger-logger/</url>
    <content><![CDATA[<p>业务日志不同于系统日志，系统日志主要用于Debug过程中，而业务日志直接面向用户，是用户操作行为的记录，项目中一般针对HTTP请求来记录业务日志，但HTTP请求函数较多，如果在每个API请求的函数中都加上记录业务日志的代码，会造成代码大量重复且低效。可以将业务日志模块独立出来，集成到中间件中，每次HTTP请求自动调用中间件模块记录业务日志。</p>
<a id="more"></a>

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件在golang中是一个很重要的概念，类似于Java中的拦截器，中间件实现了业务隔离，比如业务日志模块就可以从具体业务中抽离出来，不需要在每个业务请求代码中插入记录业务日志的代码块。</p>
<p>在golang中，中间件的代码块形式如func MyMiddleware()所示，gin.Context中包含业务所需的上下文，比如HTTP请求的信息；c.Next()用来实现业务流的下发控制，在众多中间件中会形成一条中间件链，通过中间件中的Next()函数对后续的中间件进行执行，而在每个中间件中，Next()函数前的内容在请求之前执行，Next()函数之后的内容在请求之后执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyMiddleware</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandleFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">//请求前</span></span><br><span class="line">        c.Next()</span><br><span class="line">        <span class="comment">//请求后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个中间件会形成一个栈结构，以先进先出的顺序执行，也被称为洋葱结构，如下图所示，在Request请求之前会调用所有注册的中间件，并通过Next函数一层层深入，直到所有中间件的Next都调用完成，执行Request，并拿到Response，然后通过回调函数逆序执行所有中间件中Next函数之后的内容。</p>
<img style="margin: auto;" width=300 src="./onion.png">

<p>使用中间件之后，记录业务日志模块只需要从Request中获取到请求的Path，以及从Response中获取返回的结果，就可以从swagger.json中根据Path获取详细的业务描述，以及对应的结果。</p>
<hr>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p>Swagger是一个规范和完整的框架，是用于生成、描述、调用和可视化Restful风格的Web服务。Swagger对每一个操作的请求消息的参数，响应消息的状态码等都进行了详细的描述，Swagger文档可直接从代码注释中自动生成。</p>
<p>生成的swagger.json文件格式如下图所示：</p>
<img style="margin: auto;" width=600 src="./swaggerJson.png">

<hr>
<h2 id="获取Path-summary"><a href="#获取Path-summary" class="headerlink" title="获取Path summary"></a>获取Path summary</h2><p>我们需要根据请求的API路径在swagger.json中查找到对应的path以及描述信息，拿上图举例，实际请求的path是<code>/api/surveillance/applies/1/approve</code>，需要对应到swagger中的<code>/api/surveillance/applies/{id}/approve</code>，在参数<code>1</code>到<code>{id}</code>的匹配上会存在一点难度。</p>
<h3 id="将swagger中path存储为树结构"><a href="#将swagger中path存储为树结构" class="headerlink" title="将swagger中path存储为树结构"></a>将swagger中path存储为树结构</h3><p>由于所有path都是从<code>/api</code>延续下去，因此可以使用树结构存储swagger.json中所有的path，也便于一层层地往下查找路径。</p>
<p>树中节点的结构设计如下，包含当前节点的相对路径path，所有子节点children，该节点如果是叶子节点则包含对应的request method和response信息，如果不是叶子节点，则为空，最后还有节点的类型，分为普通类型和参数类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//current node relative path</span></span><br><span class="line">  path <span class="keyword">string</span></span><br><span class="line">  <span class="comment">//all children node</span></span><br><span class="line">  children []*node</span><br><span class="line">  <span class="comment">//all request method and response</span></span><br><span class="line">  method  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="comment">//node type: normal, param</span></span><br><span class="line">  nType <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从swagger-tree树中检索"><a href="#从swagger-tree树中检索" class="headerlink" title="从swagger tree树中检索"></a>从swagger tree树中检索</h3><p>从swagger tree中检索path时，流程图如下图GetMethodInfo所示，将请求的实际path分割为一个pathSlice，依次拿pathSlice中的p去树中遍历查找，如果树中该节点是普通类型，则判断p和节点的相对路径是否相同，如果该节点是参数类型，则默认匹配children中所有节点，进行下一层的遍历，因为children中如果又一个子节点是参数类型，那么所有的子节点都是参数类型，这是由request请求的性质决定的。遍历完pathSlice中最后一个元素则结束循环，返回取到的结果。</p>
<img style="margin: auto;" width=700 src="./GetMethodInfo.png">

<p>最终根据获取到的请求描述信息，以及返回的结果生成对应的业务日志，例如：用户admin批准布控申请 成功or失败。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>middleware</tag>
        <tag>swagger</tag>
        <tag>log</tag>
      </tags>
  </entry>
</search>
